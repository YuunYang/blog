---
title:  "前端面试题总结"
categories:
  - 前端
tags: 
  - 工作
  - 前端
entries_layout: grid
author_profile: true
toc: true
toc_label: "目录"
toc_sticky: true
---
总结一下面试题，考研考不上了吧55555555555，开始准备前端春招了，争取到了头条白金码，加油吧

## Html及浏览器

### http的格式以及各部分的主要组成
- 起始行

请求报文的起始行：该行包含了一个方法和一个请求的URL，还包含HTTP 的版本。

响应报文的起始行：该行包含了响应报文使用的HTTP版本、数字状态码、原因短语。

- 头部

包含通用头部（Connection、Date、Cache-Control）、请求头部（If-None-Match、Authorization、Cookie）、响应头部（Set-Cookie、server）、实体头部（Allow（允许请求的方法）、Content-Type、ETag、Expires、Last-Modified）

### ContentType类型：
- application/x-www-form-urlencoded：提交post请求时会使用这种方式。浏览器提交原生form表单，不设置enctype时，会默认是这样的方式。
- multipart/form-data、application/json：同样是请求时使用的，指定即可。
- text/html

### 移动端适配
```javascript
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

### 从输入url到显示页面都发生了什么

- 输入url，常见的http协议的端口号是80，https是443
- 查看浏览器是否有缓存，其中分为**强制缓存**和**相对缓存**

    强制缓存：判断HTTP首部字段：cache-control表示存储的文件在多长时间内均有效、Expires表示到达系统某个时间内数据均有效
    
    相对缓存：通过HTTP的last-modified服务器返回的字段，表示最后一次更新的时间，Etag是资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。
- dns查询，分为迭代查询和递归查询
- TCP三次握手建立连接
- 浏览器向服务器发送HTTP请求
- 浏览器接收响应

    服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。
    
    状态码主要包括以下部分

    1xx：指示信息–表示请求已接收，继续处理。
    
    2xx：成功–表示请求已被成功接收、理解、接受。
    
    3xx：重定向–要完成请求必须进行更进一步的操作。
    
    4xx：客户端错误–请求有语法错误或请求无法实现。
    
    5xx：服务器端错误–服务器未能实现合法的请求。
- 页面渲染
    
    其中会涉及到reflow（回流，会导致重新渲染）和repaint（重绘，只会重画一部分）。

    减少reflow/repaint的措施：
    1. 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。 
    2. 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。 
    3. 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。 
    4. 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。

### http和https区别    
HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

### session,cookie,sessionStorage,localStorage的区别及应用场景
- cookie和session都是用来跟踪浏览器用户身份的会话方式。cookie保存在浏览器端，session保存在服务器端。cookie虽然保存在浏览器端，但Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它。
- session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。
- 应用场景：
    - cookie： 网上商城中的购物车、保存用户登录信息、将某些数据放入session中，供同一用户的不同页面使用、防止用户非法登录
    - session：Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。主要用于：网上商城中的购物车、保存用户登录信息、将某些数据放入session中，供同一用户的不同页面使用、防止用户非法登录。
- localStorage与sessionStorage： 
    - localStorage：localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据
    - sessionStorage：的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。sessionStorage：敏感账号一次性登录；
    - 存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。
    - 获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。

### css、js、dom的渲染关系
- css不会阻碍dom的解析，但会阻碍dom渲染，很好理解。
- js会阻碍dom解析。
- 遇到js时，如果没有async或defer标签，会触发页面渲染。

## JavaScript

### js基本数据类型
Boolean、Undefined、Null、Number、String、Object

### js获取变量类型的几种方法
- typeof：可以判断基本类型，但无法判断对象具体类型；且当判断基本包装类型创建的实例如
new String()时会判断成Object
- Object.prototype.toString.call()：可以判断具体对象类型，可以把new Array()、new Reg()分别判断成数组和正则表达式
- instanceof：变量 instanceof 对象类型，返回Boolean值，且如new Array() instanceof Array或Object都返回true。当instanceof undefined和null时会报错。

### js深克隆
```javascript
let cloneObj = function(obj){
    let str, result = obj.constructor === Array ? [] : 
        obj.constructor ? new obj.constructor : {};

    if (!obj || typeof obj !== 'Object') {
        return obj;
    }
    for (let key in obj) {
        result[key] = cloneObj(obj[key]);
    }
    return result;
}
```

### setTimeOut和promise区别
promise的优先级比setTimeOut高，其中promise的then和setTimeout都是依次加入到消息队列后面去的。

### setTimeout谈js运行机制
[来自cnblog](https://www.cnblogs.com/zichi/p/4604053.html)

Js有一个运行队列如图

![img][timer-01]

如图，setTimeOut和setInterval都是追加到运行队列中的

对于setTimeOut和setInterval的对比，setInterval可以通过setTimeout通过递归调用实现
```javascript
function func() {
  setTimeout(function() {
    // some code
    func();
  }, 10);
}
```
但区别是，setInterval的回调是并列的，前一个回调（有没有执行）并不会影响后一个回调（插入队列），同时，如果等待队列里已经有同一个interval函数的回调了，将不会有相同的回调插入等待队列（有点像函数防抖）；而setTimeout之间的回调是嵌套的，后一个回调是前一个回调的回调，所以造成setTimeOut的执行时间往往大于设定的时间，因为每次插入到后续队列，都需要等待代码执行完成。

### 函数节流 
是为了限制函数一段时间内只能执行一次，在延时的时间内，方法若被触发，则直接退出方法，这是与防抖的区别，防抖是在延时内触发则重新计时，也就是每次都只执行一段时间的最后一次
``` javascript
const _.throttle = (func, wait) => {
    let timer;
    return () => {
        if (timer) {
            return;
        }

        timer = setTimeout(() => {
            func();
            timer = null;
        }, wait);
    };
};
```

### 函数防抖
函数防抖在执行目标方法时，会等待一段时间。当又执行相同方法时，若前一个定时任务未执行完，则 clear 掉定时任务，重新定时。
``` javascript
const _.debounce = (func, wait) => {
    let timer;

    return () => {
        clearTimeout(timer);
        timer = setTimeout(func, wait);
    };
};
```

### var和let的区别
通过var定义的变量，作用域是整个封闭函数，是全域的 。通过let定义的变量，作用域是在块级或是子块中。
且var会提升变量
``` javascript
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;
//相当于
var foo;  //声明且初始化为undefined
console.log(foo);
foo=2;
```

### js构造函数和原型对象
[总结自cnblog](http://www.cnblogs.com/thonrt/p/5900510.html)

构造函数所有的实例对象都可以继承构造器函数中的属性和方法。但是，同一个对象实例之间，无法共享属性

![uml图][construct-01]
由图可以看出，propotype是构造函数（Person()）的属性，而consructor则是构造函数的prototype属性所指向的那个对象，也就是说constuctor是原型对象的属性。constructor属性是定义在原型对象上面，意味着也可以被实例对象继承。

同样也可以得出结论，就是console.log(girl.construcotr); //Person()
console.log(girl.construcotr == Person.propotype.construcotr); //true

而由于箭头函数的this往往指向的是最先一个闭包（作为函数，通常是window），所以箭头函数不能作为构造函数（因为构造函数要求指向实例化后this指向实例对象）。


### new()操作到底做了什么
使用 new 操作符创建实例。以这种方式调用构造函数实际上会经历以下 4
个步骤：
- 创建一个新对象；
- 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；
- 执行构造函数中的代码（为这个新对象添加属性） ；
- 返回新对象。

``` javascript
var obj = new Base();
// 等价于
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
//随后通过Base.prototype.xxx = () => {}为Base添加方法时，obj也同时拥有此方法
```

三种引用类型（String Number Boolean）是没有属性和方法的，但仍然可以使用对象才有的属性方法。这时因为在对基本类型使用属性方法的时候，后台会隐式的创建这个基本类型的对象，之后再销毁这个对象

### Call、bind、apply
总结自来自[简书-JavaScript中的call、apply、bind深入理解](https://www.jianshu.com/p/00dc4ad9b83f)

- Call：首先寻找call方法，最后通过原型链在Function的原型中找到call方法，然后让call方法执行，在执行call方法的时候，让fn方法中的this变为第一个参数值obj，最后再把fn这个函数执行，只是改变fn中的this的指向。
- apply：作用与call类似，只是后面的参数用数组绑定
- bind：同样会改变this的指向，但不会立即执行

### [跨域](https://segmentfault.com/a/1190000011145364)
- jsonp
    ```javascript
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参并指定回调执行函数为onBack
    script.src = 'http://www.domain-com:8080/login?user=admin&callback=onBack';
    document.head.appendChild(script);

    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
    ```
- document.domain + iframe跨域
    ```javascript
    //父窗口：(http://www.domain.com/a.html)
    <iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
    <script>
        document.domain = 'domain.com';
        var user = 'admin';
    </script>
    //子窗口：(http://child.domain.com/b.html)
    <script>
        document.domain = 'domain.com';
        // 获取父窗口中变量
        alert('get js data from parent ---> ' + window.parent.user); //"admin"
    </script>
    ```
- location.hash + iframe

    与document.domain类似，不同的是，通过修改父页面的iframe的src进而达到修改window.hash的效果，子页面通过window.onhashchange来监听
- window.name + iframe跨域
- 跨域资源共享（CORS）

    前端正常请求，后端设置：
    ```javascript
    res.writeHead(200, {
        'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
        'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
        /* 
            * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
            * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
            */
        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
    });
    ```
- nginx代理跨域
- nodejs中间件代理跨域
- WebSocket协议跨域

### 原生JavaScript实现Ajax
```javascript
//Get请求

//步骤一:创建异步对象
var ajax = new XMLHttpRequest();
//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端
ajax.open('get','getStar.php?starName='+name);
//步骤三:发送请求
ajax.send();
//步骤四:注册事件 onreadystatechange 状态改变就会调用
ajax.onreadystatechange = function () {
if (ajax.readyState==4 &&ajax.status==200) {
    //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的
　　　　console.log(ajax.responseText);//输入相应的内容
　　}
}

//POST请求

//创建异步对象  
var xhr = new XMLHttpRequest();
//设置请求的类型及url
//post请求一定要添加请求头才行不然会报错
xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
xhr.open('post', '02.post.php' );
//发送请求
xhr.send('name=fox&age=18');
xhr.onreadystatechange = function () {
        // 这步为判断服务器是否正确响应
    if (xhr.readyState == 4 && xhr.status == 200) {
        console.log(xhr.responseText);
    }
};
```

## Css

### 垂直居中
- display: flex
```css
.content{
    display: flex;
    justify-content:center;
    align-items:Center;
}
```
- 绝对定位和负边距
```css
.outer{position:relative;}
.outer .content{
    position: absolute;
    width:100px;
    height: 50px;
    top:50%;
    left:50%;
    margin-left:-50px;//width的一半
    margin-top:-25px; //height的一半
    text-align: center;
}
```
- translate
```css
.outer{position:relative;}
.outer .content{
    position: absolute;
    top:50%;
    left:50%;
    width: 100%;
    transform: translate(50%, 50%);
    text-align: center;
}
```

### translate、transform和translation，以及动画animation
- translate：移动，是transform的一个方法。translate(x,y)表示在x轴y轴方向移动x，y个单位。
- transform：变形，改变。**rotate()** 顺时针旋转给定的角度；**skew()** 元素翻转给定的角度，根据给定的水平线(x轴)和垂直线（Y轴）参数：skew(30deg,20deg)；scale()放大或缩小，根据给定的宽度（X轴）和高度（Y轴）参数：scale(2,4)；**translate()** 平移，传进x,y值，代表沿x轴和y轴平移的距离；**matrix()** 旋转、缩放移动以及倾斜元素matrix(scale.x,scale.y,translate.x,translate.y)；改变起点位置 **transform-origin** : bottom left;
- transition: 允许css属性值在一定的时间区间内平滑的过渡，即过渡动画。transition作用是指定了某一个属性（如width、left、transform等）在两个值之间如何过渡。
- animation是指定keyframes的动画，具体是
```css
animation:mymove 5s infinite;
-webkit-animation:mymove 5s infinite; /*Safari and Chrome*/
}

@keyframes mymove
{
    from {left:0px;}
    to {left:200px;}
}
```

### margin
- margin的大小问题：当两元素水平方向时，margin为左边右margin+右边左margin相加；当竖直方向时，margin为上面元素下margin和下面元素上margin中的最大值；当内容为空且设置有上下margin时，元素高度为上下margin中的最大值。
- 父子元素中的margin：当给在父元素中，给子元素简单的添加一个margin-top时，是达不到预期效果的，（它会使父子元素整个向下偏移，而父子元素的相对位置却没有变），除了一些常规方法，可以为父元素添加overflow: hidden属性；margin-top的%值是相对于父元素的宽度而非高度。

### BFC
[BFC即Block Formatting context，块格式化上下文](https://juejin.im/post/59b73d5bf265da064618731d)

- 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）；
- 处于同一个BFC中的元素相互影响，可能会发生margin collapse（margin塌陷）；
- 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此；
- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；
- 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；
- 浮动盒区域不叠加到BFC上；

## React & Redux

### Redux基础：
- Action 是把数据从应用传到 store 的有效载荷。它是 store 数据的*唯一*来源。一般来说你会通过 store.dispatch() 将 action 传到 store
- Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state
- Store 就是把Action和Reducers联系到一起的对象。Store 有以下职责：
    维持应用的 state；
    提供 getState() 方法获取 state；
    提供 dispatch(action) 方法更新 state；
    通过 subscribe(listener) 注册监听器;
    通过 subscribe(listener) 返回的函数注销监听器。

    Redux 应用只有一个单一的 store。当需要拆分数据处理逻辑时，你应该使用combineReducers 来 reducer 组合 而不是创建多个 store。

### Diff算法
[来自知乎](https://zhuanlan.zhihu.com/p/20346379?refer=purerender)
- treeDiff
    
    React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。
    
    ![diff-01][diff-01]
- element diff
    当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。

    INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。

    MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。

    REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。

- 对于key的用法，如果没有key的话，根据diff算法，则当对比不对时，会直接删除旧的，追加新的
    
    ![diff-02][diff-02]

    而当为每个节点设置了唯一的key之后，则可以通过判断不同节点的key值，将节点不断后移即可。（注意是后移，因为在新集合之中，相对老集合处于后面位置的话，移动是不影响前面的，所以放一边，是一种优化）

    ![diff-03][diff-03]


[diff-01]: /assets/images/2018-12-25-front-end/01.png
[diff-02]: /assets/images/2018-12-25-front-end/02.png
[diff-03]: /assets/images/2018-12-25-front-end/03.png
[construct-01]: /assets/images/2018-12-25-front-end/04.png
[timer-01]: /assets/images/2018-12-25-front-end/05.png