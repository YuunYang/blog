---
title:  "前端面试题总结-补01"
categories:
  - FrontTech
tags: 
  - 工作
  - 前端
entries_layout: grid
author_profile: true
toc: true
toc_label: "目录"
toc_sticky: true
---
前端面试题第二波
[前端面试题总结](/fronttech/front-end/)

[计算机网络总结](/fronttech/network/)

[常见代码题](/fronttech/common-algorithms/)

## 实习相关
主要记录一下当面试官问道暑期实习的相关问题时，该怎么回答。
### 介绍一下实习期间的工作
（2018年美团实习）实习期间主要负责的是B端的各类工作，包括给统计每天各城市、各商家销售情况的统计图表类项目，主要的工作内容是页面和前端接口的编写；以及还有实习最后阶段开发用于内部负责数据分析工作同事使用的实现类似自定义页面的系统。
### 实习期间遇到的主要问题
主要问题是新框架的适应问题，实习期间用到了一种接口描述语言“thrift”（Thrift包含一套完整的栈来创建客户端和服务端程序。顶层部分是由Thrift定义生成的代码。而服务则由这个文件客户端和处理器代码生成。在生成的代码里会创建不同于内建类型的数据结构，并将其作为结果发送。协议和传输层是运行时库的一部分。有了Thrift，就可以定义一个服务或改变通讯和传输协议，而无需重新编译代码。除了客户端部分之外，Thrift还包括服务器基础设施来集成协议和传输，如阻塞、非阻塞及多线程服务器。栈中作为I/O基础的部分对于不同的语言则有不同的实现），还有就是开发过程中会用到一些小组内部重构或整合的UI库，随着react版本的迭代，很多库都变得老化臃肿，所以开发过程中还需要不断地踩坑填坑。（待补充，一两个react组建的坑）
### 实习期间最大的收获是什么
实习期间最大的收获首先是认识了很多不错的同事，同事会进行code view，所以经过实习之后，会更注意代码规范。
### introduce your self
Hello thank you for giving me the opportunity for this interview, my name is yangyukun and I will graduate from Wuhan Institute of Technology this year. I have a two-month internship as a front-end engineer in Meituan, and have been involved in a lot of to-B projects. I've always been interested in programming and enjoy everything that I do. I know that xx is a technology-driven company, which I am very interested in, so Good luck today.

## React
### react生命周期
1. componentWillMount()
2. render()

在componentWillMount()方法之后
在componentWillReceive(nextProps, nextState)方法之后
3. componentDidMount()
4. componentWillReceiveProps(nextProps)
5. shouldComponentUpdate(nextProps, nextState)

`shouldComponentUpdate()` 返回 `false`，这就意味着 `componentWillUpdate()`、 `render()` 和 `componentDidUpdate()` 将不再执行
6. componentWillUpdate(nextProps, nextState)

不可以调用`setState()`
7. componentDidUpdate(prevProps, prevState)
8. componentWillUnmount()

### [react context](https://juejin.im/post/5a90e0545188257a63112977)
context被翻译为上下文，当在组件树中不想通过`props`或者`state`的方式来传递数据时，可以使用`context`来实现跨层级组件传递，有很多react组件都是通过context来完成自己的功能，比如react-redux的`<Provider />`，就是通过context提供一个全局态的store

当使用`props`或`state`时，数据是自顶向下流，也就是一层一层的传递，而context则可以跨越组件进行数据传递（其实也就导致了不稳定，所以官方并不推荐在稳定版本的react中使用）

如果要Context发挥作用，需要用到两种组件，一个是Context生产者(Provider)，通常是一个父节点，另外是一个Context的消费者(Consumer)，通常是一个或者多个子节点。所以Context的使用基于生产者消费者模式（想想redux怎么用的）

### react/redux设计模式
react/redux构架中观察到的最重要的一种结构模式是中介者模式，他允许我们公开一个统一的接口，系统不同部分可以通过该接口进行通讯。

react/redux这个组合中严格贯彻了中介者模式的思想，redux为单一state管理提供了解决方法。单一对象在处理复杂数据变化的时候可以协调指挥，不至于交叉变化引用。中介者可以处理多个委托人的请求，处理一个委托人的请求也不在话下。而且在增加委托者的时候对系统中其他委托者是没有影响的，他们都是独立存在的，只和中介者发生通讯联系。如果用单元测试的方法来测试也很容易。

### mvvm设计模式
最常见的客户端架构有三种：

- MVC: Model-View-Controller

View通过Controller来和Model联系，Controller是View和Model的协调者，View和Model不直接联系，基本联系都是单向的。

用户User通过控制器Controller来操作模板Model从而达到视图View的变化。
- MVP: Model-View-Presenter

是从MVC模式演变而来的，都是通过Controller/Presenter负责逻辑的处理+Model提供数据+View负责显示。在MVP中，Presenter完全把View和Model进行了分离，主要的程序逻辑在Presenter里实现。并且，Presenter和View是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更View的时候可以保持Presenter不变。
- MVVM: Model-View-ViewModel

MVVM是把MVC里的Controller和MVP里的Presenter改成了ViewModel。Model+View+ViewModel。View的变化会自动更新到ViewModel,ViewModel的变化也会自动同步到View上显示。这种自动同步是因为ViewModel中的属性实现了Observer，当属性变更时都能触发对应的操作。

## ES6
[阮一峰](http://es6.ruanyifeng.com/)，只记录一下难点。
### Proxy & Reflect
[Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。](http://es6.ruanyifeng.com/#docs/proxy#%E6%A6%82%E8%BF%B0)

Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与[处理器对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler)的方法相同。

### super、Extends关键字
[Js ES6中的”Super“和”Extends](/fronttech/Super-and-Extends-In-ES6)以及原文链接[https://medium.com/@anurag.majumdar](https://medium.com/beginners-guide-to-mobile-web-development/super-and-extends-in-javascript-es6-understanding-the-tough-parts-6120372d3420)
### fetch与传统Ajax
首先了解到Ajax的本质是使用XMLHttpRequest对象来请求数据，fetch则是全局window的一个方法，而且它使用ES6 Promise来处理回调和结果，所以也需要浏览器支持ES6。

Fetch和Ajax主要有两种方式的不同；其中第一个是从Fetch返回的 Promise不会拒绝HTTP错误状态, 即使响应是一个 HTTP 404 或 500，相反，它会正常解决 (其中ok状态设置为false),。仅在网络故障时或任何阻止请求完成时，它才会拒绝。如果有需求一般都可以自行封装。

第二个是Fetch在默认情况下在服务端不会发送或接收任何cookie，如果站点依赖于维护一个用户会话，则可能导致未经认证的请求。如果需要可以在参数中加上credentials
```javascript
fetch(url, {
  credentials: ’same-origin', // credentials: ’include'
})
```
### Promise封装Ajax请求
```javascript
let ajax = (obj) => {
    return new Promise((resolve, reject) => {
        let method = obj.method || 'GET';
        let xhr = null;
        if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
        } else {
            xhr = new ActiveXObject('Microsoft.XMLHTTP');
        }
        xhr.onReadyStateChange = () => {
            if (xhr.readyState == 4) {
                if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                    resolve(xhr.responseText);
                } else {
                    reject(xhr.statusText);
                }
            }
        }
        if (method == 'POST') {
            xhr.open('POST', obj.url, true);
            xhr.responseType = "json";
            xhr.setRequestHeader("Accept", "application/json");
            xhr.send(obj.data);
        } else {
            let query = '';
            for (let key in obj.data) {
                query += '&' + encodeURIComponent(key) + "=" + encodeURIComponent(obj.data[key]);
            }
            query.substring(1);
            xhr.open('GET', obj.url + '?' + query, true);
            xhr.send();
        }
    })
}
```

## 计算机相关
### Linux常用命令
- `ps -aux`：查看执行中的程序的一个指令
- `kill`：用来杀进程的，需配合 ps 这个指令，如`kill 100`
- `netstat -tln`：查看端口使用情况
- `netstat -tln | grep 8083 `：只查看端口8083的使用情况