---
title:  "前端面试题总结-补01"
categories:
  - FrontTech
tags: 
  - 工作
  - 前端
entries_layout: grid
author_profile: true
toc: true
toc_label: "目录"
toc_sticky: true
---
前端面试题第二波

## 实习相关
主要记录一下当面试官问道暑期实习的相关问题时，该怎么回答。
### 介绍一下实习期间的工作
（2018年美团实习）实习期间主要负责的是B端的各类工作，包括给统计每天各城市、各商家销售情况的统计图表类项目，主要的工作内容是页面和前端接口的编写；以及还有实习最后阶段开发用于内部负责数据分析工作同事使用的实现类似自定义页面的系统。
### 实习期间遇到的主要问题
主要问题是新框架的适应问题，实习期间用到了一种接口描述语言“thrift”（Thrift包含一套完整的栈来创建客户端和服务端程序。顶层部分是由Thrift定义生成的代码。而服务则由这个文件客户端和处理器代码生成。在生成的代码里会创建不同于内建类型的数据结构，并将其作为结果发送。协议和传输层是运行时库的一部分。有了Thrift，就可以定义一个服务或改变通讯和传输协议，而无需重新编译代码。除了客户端部分之外，Thrift还包括服务器基础设施来集成协议和传输，如阻塞、非阻塞及多线程服务器。栈中作为I/O基础的部分对于不同的语言则有不同的实现），还有就是开发过程中会用到一些小组内部重构或整合的UI库，随着react版本的迭代，很多库都变得老化臃肿，所以开发过程中还需要不断地踩坑填坑。（待补充，一两个react组建的坑）
### 实习期间最大的收获是什么
实习期间最大的收获首先是认识了很多不错的同事，同事会进行code view，所以经过实习之后，会更注意代码规范。

## Javascript
### 原生js解析cookie

```javascript
function getCookie(name)
{
    var arr,reg=new RegExp("(^| )"+name+"=([^;]*)(;|$)");
    if(arr=document.cookie.match(reg))
        return unescape(arr[2]);
    else
        return null;
}
```
正则解释：**^| name**表示匹配开始或者匹配空格，**=([^;]*)**匹配‘=’加上后面的一直的非‘;’，最后 **(;|$)**匹配最后的‘;’或最后结束

### jS实现兼容的div拖放功能

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>tmp.html</title>
    <style>
        .content {
            background-color: #bfbfbf;
            height: 500px;
        }
        .obj {
            position: absolute;
            top: 0;
            left: 0;
            width: 100px;
            height: 100px;
            border: 1px solid green;
            background-color: orange;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content" id="obja"></div>
        <div class="obj" id="objb"></div>
        <p id="para"></p>
    </div>
    <script>
        var flag = false;
        var sx, sy, cx, cy, dx, dy;
        var obj = document.getElementById("objb");
        if(obj.addEventListener) { // 除IE8已下都可以
            obj.addEventListener('mousedown', function(event) {dragStart(event);}, false);
            obj.addEventListener('mousemove', function(event) {dragMove(event);}, false);
            document.body.addEventListener('mouseup', function(event) {dragEnd(event);}, false);
        }
        else if(obj.attachEvent){
            obj.attachEvent('onmousedown', function(event) {dragStart(event);});
            obj.attachEvent('onmousemove', function(event) {dragMove(event);});
            document.body.attachEvent('onmouseup', function(event) {dragEnd(event);});
        } else {
            obj['onmousedown'] = function(event) {dragStart(event);}
            obj['onmousemove'] = function(event) {dragMove(event);}
            obj['onmouseup'] = function(event) {dragEnd(event);}
        }
        function dragStart(event) {
            flag =true;
            sx = event.clientX;
            sy = event.clientY; // client是moseevent，所以sx，sy为鼠标的位置，要判断鼠标在框框内
            dx = obj.offsetLeft;
            dy = obj.offsetTop;
        }
        function dragMove(event) {
            if(flag) {
                cx = event.clientX;
                cy = event.clientY;
                obj.style.left = cx - sx + dx + 'px';
                obj.style.top = cy - sy + dy + 'px';
                if(event.preventDefault) { // 可加可不加
                    document.addEventListener("mousemove", function(){
                        event.preventDefault(); // 默认动作不要做                 
                    }, false); // false代表事件冒泡，true代表事件捕获
                } else {
                    document.attachEvent("onmousemove", function(){
                        window.event.returnValue = false;
                    });
                }
            }
        }
        function dragEnd(event) {
            flag = false;
        }
    </script>
</body>
</html>
```

### 原生实现autocomple
```html
 <div id="div1">
    <input type="text" id="input" placeholder="有autocomplete的输入框"/>
    <ul id="ul">
    </ul>
</div>
```
```css
*{
    margin: 0;
    padding: 0;
    box-sizing:border-box;
}
ul{
    list-style: none;
    margin: 0 auto;
    background-color: #ededed;
    color: #3b200c;
    width: 400px;
    border: none;
}
li{
    cursor: pointer;
}
input{
    display: block;
    margin: 0 auto;
    line-height: 40px;
    height: 40px;
    width: 400px;
    font-size: 20px;
}
```
```javascript
var arr = ['a','apple','abandon','bilibili','beep','before','become','being','highmaintains','by','bye','banana']
input.addEventListener('input', function(event){
    var _value = event.target.value.trim()
    if(_value){
        autoComplete(_value, arr)
    }
    else{
        ul.innerHTML = ''
    }
})
function autoComplete(str, arr){
    var lis = []
    arr.forEach((word)=>{
        if(word.startsWith(str)){
            lis.push('<li>' + word + '</li>')
        }
    })
    ul.innerHTML = lis.join('')
}
function addToInput(li){
    var _txt = li.innerText
    input.value = _txt
}
ul.addEventListener('click', function(event){
    if(event.target.tagName.toLowerCase() === 'li'){
        addToInput(event.target)
    }
})
```

### react生命周期
1. componentWillMount()
2. render()

在componentWillMount()方法之后
在componentWillReceive(nextProps, nextState)方法之后
3. componentDidMount()
4. componentWillReceiveProps(nextProps)
5. shouldComponentUpdate(nextProps, nextState)

`shouldComponentUpdate()` 返回 `false`，这就意味着 `componentWillUpdate()`、 `render()` 和 `componentDidUpdate()` 将不再执行
6. componentWillUpdate(nextProps, nextState)

不可以调用`setState()`
7. componentDidUpdate(prevProps, prevState)
8. componentWillUnmount()

### react/redux设计模式
react/redux构架中观察到的最重要的一种结构模式是中介者模式，他允许我们公开一个统一的接口，系统不同部分可以通过该接口进行通讯。

react/redux这个组合中严格贯彻了中介者模式的思想，redux为单一state管理提供了解决方法。单一对象在处理复杂数据变化的时候可以协调指挥，不至于交叉变化引用。中介者可以处理多个委托人的请求，处理一个委托人的请求也不在话下。而且在增加委托者的时候对系统中其他委托者是没有影响的，他们都是独立存在的，只和中介者发生通讯联系。如果用单元测试的方法来测试也很容易。

[Redux设计思想与使用场景](https://segmentfault.com/a/1190000015367584)